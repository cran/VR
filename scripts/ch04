#-*- S -*-  

# Chapter 4   Programming in S

# need R -n 250000 for conv1(a,b)

library(MASS)
postscript(file="ch04.ps", width=8, height=6, pointsize=9)


# 4.1  Control structures

yp <- rpois(50, lam=1)   # full Poisson sample of size 50
table(yp)
y <- yp[yp > 0]          # truncate the zeros
ybar <- mean(y); ybar
lam <- ybar
it <- 0                  # iteration count
del <- 1
while (abs(del) > 0.0001 && (it <- it + 1) < 10) {
    del <- (lam - ybar*(1 - exp(-lam)))/(1 - ybar*exp(-lam))
    lam <- lam - del
    cat(it, lam, "\n")
    }


# 4.2  Vectorized calculations and loop avoidance functions

data(iris3)
apply(iris3, c(2,3), mean)
apply(iris3, c(2,3), mean, trim=0.1)
apply(iris3, 2, mean)
ir.var <- apply(iris3, 3, var)
ir.var <- array(ir.var, dim = dim(iris3)[c(2,2,3)],
                dimnames = dimnames(iris3)[c(2,2,3)])

matrix(rep(1/50, 50) %*% matrix(iris3, nrow = 50), nrow = 4, 
         dimnames = dimnames(iris3)[-1])

ir.means <- apply(iris3, c(2,3), mean)
sweep(iris3, c(2,3), ir.means)
log(sweep(iris3, c(2,3), ir.means, "/"))

data(quine)
attach(quine)
table(Age)
table(Sex, Age)

#tab <- crosstabs(~Sex + Age, quine)
#unclass(tab)


tapply(Days, Age, mean)
tapply(Days, Age, mean, trim = 0.1)
tapply(Days, list(Sex, Age), function(x) sqrt(var(x)/length(x)))


conv1 <- function(a, b) {
    ab <- outer(a, b)
    unlist(lapply(split(ab, row(ab) + col(ab)), sum))
}
conv2 <- function(a, b) {
    ab <- outer(a, b)
    tapply(ab, row(ab) + col(ab), sum)
}

a <- runif(1000)
b <- runif(100)
print(unix.time(conv1(a, b)))
print(unix.time(conv2(a, b)))

Letters <- c(LETTERS, letters)
Letters[sapply(Letters, function(xx) exists(xx))]
Letters[sapply(Letters, function(x) exists(x))]
Letters[sapply(Letters, exists)]

sapply(list(quine, quine), function(x) dim(x))

sapply(quine, is.factor)
quineFO <- quine[,sapply(quine, is.factor)]  
tab <- do.call("table", quineFO) # or just table(quineFO) in R
tab

QuineF <- expand.grid(lapply(quineFO, levels))
QuineF <- do.call("expand.grid", lapply(quineFO, levels))  
QuineF$Freq <- as.vector(tab)
QuineF

#aggregate(crabs[, 4:8], list(sp=crabs$sp, sex=crabs$sex), median)
#by(crabs[,4:8], list(crabs$sp, crabs$sex), summary)
#merge(Animals, mammals, by="row.names")

# 4.3   is do-it-yourself!

# 4.6  Calling the operating system

#file.exists <- function(name)
#   unix(paste("test -r", name), output.to.S=F) == 0
objchk <- function(x, y)
{
   old <- tempfile("old"); dput(x, old)
   new <- tempfile("new"); dput(y, new)
   unix(paste("diff", old, new), output = F)
   unlink(c(old, new))
   invisible()
}
to.upper <- function(str) unix('tr "[a-z]" "[A-Z]"',str)
to.lower <- function(str) unix('tr "[A-Z]" "[a-z]"',str)
# for DOS:
#file.exists <- function(name)
#   length(dos(paste("attrib", name))) > 0


# 4.7  Recursion and handling vectorization

subsets <- function(r, n, v = 1:n)
   if(r <= 0) NULL else 
   if(r >= n) v[1:n] else 
   rbind(cbind(v[1], Recall(r - 1, n - 1, v[-1])), 
                     Recall(r,     n - 1, v[-1]))

subsets(3, 5)

library(integrate)
Integrate <- function(...) 
  structure(integrate(...), class = "integral")
print.integral <- function(x, ...) {
    y <- x
    x <- x$finest
    NextMethod("print")
    invisible(y)
  }

Integrate(sin, 0, pi)
Integrate(function(x) 2, 0, 1) # works in R
Integrate(function(x) rep(2, length(x)), 0, 1)

# integrate in R has argument eps to which e matches, so e -> ee
gn <- function(x, d, ee) prod(d*x + ee)
fn <- function(x, d, ee) apply(outer(d, x) + ee, 2, prod)  
Integrate(fn, -4, -2, d = 1:3, ee = 4:6)
Integrate(gn, -4, -2, d = 1:3, ee = 4:6) # works in R



# 4.8  Frames

# cannot use trace here, as R's is `in very primitive form'
fn <- function(x, d, ee) {
  assign(".x",c(.x,x), envir=.GlobalEnv)
  apply(outer(d, x) + ee, 2, prod)
}
.x <- NULL
Integrate(fn, -4, -2, d = 1:3, ee = 4:6)
plot(.x, fn(.x, 1:3, 4:6), xlab="x", ylab="fn(x, d, e)")



# =========================================

# Chapter 4 Complements


# 4.9  Using C and Fortran Routines

# The C and Fortran code is in file ch04c, together with the S driver code.


# 4.13  Group method functions 

polynomial <- function(a = c(0, 1))
{
  a <- as.numeric(a)
  while((la <- length(a)) > 1 && a[la] == 0) a <- a[-la]
  structure(a, class = "polynomial")
}

is.polynomial <- function(p) inherits(p, "polynomial")

as.polynomial <- function(p)
  if(is.polynomial(p)) p else polynomial(p)

"+.polynomial" <- function(e1, e2) 
{
  if(missing(e2)) return(e1)
  e1 <- c(unclass(e1), rep(0, max(0, length(e2) - length(e1))))
  e2 <- c(unclass(e2), rep(0, max(0, length(e1) - length(e2))))
  polynomial(e1 + e2)
}

Ops.polynomial <- function(e1, e2)
{
  if(missing(e2))
    return(switch(.Generic,
                  "+" = e1, 
                  "-" = polynomial(NextMethod(.Generic)),
                  stop("unsupported unary operation")))
  e1 <- unclass(e1)
  e2 <- unclass(e2)
  l1 <- length(e1)
  l2 <- length(e2)
  e1.op.e2 <- 
    switch(.Generic,
           "+" = , "-" = {
             e1 <- c(e1, rep(0, max(0, l2 - l1)))
             e2 <- c(e2, rep(0, max(0, l1 - l2)))
             NextMethod(.Generic)
           },
           "*" = if(l1 == 1 || l2 == 1) e1 * e2 else {
             m <- outer(e1, e2)
             as.vector(tapply(m, row(m) + col(m), sum))
           },
           "/" = {
             if(l2 > 1 || e2 == 0)
               stop("unsupported polynomial division")
             e1/e2
           },
           "^" = {
             if(e2 < 0 || e2 %% 1 != 0)
               stop("unsupported polynomial power")
             switch(as.character(e2),
                    "0" = 1,
                    "1" = e1,
                    {
                      p <- q <- polynomial(e1)
                      for(i in 2:e2)
                        p <- p * q
                      as.numeric(p)
                    })
           },
           "==" = return(l1 == l2 && all(e1 == e2)),
           "!=" = return(l1 != l2 || any(e1 != e2)),
           stop("unsupported operation on polynomials"))
  polynomial(e1.op.e2)
}    
Summary.polynomial <- function(p)
{
    stop(paste(.Generic, "invalid for polynomials"))
}
Math.polynomial <- function(p, digits)
{
  switch(.Generic,
         round = , signif = , floor = , ceiling = ,
         trunc = polynomial(NextMethod(.Generic)),
         stop(paste(.Generic, "unsupported for polynomials")))
}

horner <- function(p)
{
  a <- as.character(rev(unclass(p)))
  h <- a[1]
  while(length(a <- a[-1]) > 0) {
    h <- paste("x*(", h, ")", sep = "")
    if(a[1] != 0)
      h <- paste(a[1], " + ", h, sep = "")
  }
  h
}

x <- polynomial()
p <- (x^2 + 1)^2
horner(p)

as.character.polynomial <- function(p)
{
  p <- unclass(p)
  lp <- length(p) - 1
  names(p) <- 0:lp
  p <- p[p != 0]

  if(length(p) == 0) return("0")

  signs <- ifelse(p < 0, "- ", "+ ")
  if(signs[1] == "- ") signs[1] <- "-"
  else signs[1] <- ""

  np <- names(p)
  p <- as.character(abs(p))
  p[p == "1" & np != "0"] <- ""

  pow <- paste("x^", np, sep = "")
  pow[np == "0"] <- ""
  pow[np == "1"] <- "x"
  stars <- rep("*", length(p))
  stars[p == "" | pow == ""] <- ""
  paste(signs, p, stars, pow, sep = "", collapse = " ")
}  
# this is wrong in R as as.character() is not generic
as.character.polynomial(p)

print.polynomial <- function(p0, ...)
{
  p <- as.character.polynomial(signif(p0, 
                           digits = options("digits")$digits))
  pc <- nchar(p)
  ow <- max(35, options("width")$width)
  m2 <- 0
  while(m2 < pc) {
     m1 <- m2 + 1
     m2 <- min(pc, m2 + ow)
     if(m2 < pc)
        while(substring(p, m2, m2) != " " && m2 > m1 + 1) 
           m2 <- m2 - 1
     cat(substring(p, m1, m2), "\n")
  }
  invisible(p0)
}  

# R version is like as.function.poly2
as.function.polynomial <- function(p)
{
  f <- function(x) NULL
  body(f) <- parse(text = horner(p))[[1]]
  f
}  

fp <- as.function(p)
fp
fp(1:3)


if(F){
# no R version of "as.{"
as.function.poly2 <-  function(p)
{
    f <- function(x) {}
    body <- c(paste("val <- ", horner(p)), "val")
    body <- parse(text = body)
    mode(body) <- "{"
    f[[2]] <- body
    f
}
as.function.poly2(p)

poly.orth <- function(x, degree = length(unique(x)) - 1, norm = T)
{
  at <- attr(poly(x, degree), "coefs") # not yet implemented
  a <- at$alpha
  N <- at$norm2
  x <- polynomial()
  p <- list(polynomial(0), polynomial(1))
  for(j in 1:degree)
    p[[j + 2]] <- 
      (x - a[j]) * p[[j + 1]] - N[j + 1]/N[j] * p[[j]]
  p <- p[-1]
  if(norm) {
    sqrtN <- sqrt(N[-1])
    for(j in 1 + 0:degree) p[[j]] <- p[[j]]/sqrtN[j]
  }
  p
}  
poly.orth(0:5, degree = 4, norm = F)
}

# End of ch04
